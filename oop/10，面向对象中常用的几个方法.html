<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
	<script type="text/javascript">
//		一,hasOwnProperty  验证某个属性是不是属于某个对象所特有
//		var arr=[];
//		arr.num=10;
//		Array.prototype.num2=20
//		console.log(arr.hasOwnProperty('num'));  //true
//		console.log(arr.hasOwnProperty('num2'));   //false
//		var arr2=[1,2,3];
//		alert(arr2.num2);
		
//		二,constructor (构造函数) 查看实例对象的构造函数是谁
//		(1)示例1
//		function creatAnimal(){}
//		var a1=new creatAnimal();
//		alert(a1.constructor);  //得到了a1的构造函数是creatAnimal
//		(2)示例2，系统对象的构造函数
//		var arr=[];
//		alert(arr.constructor==Array);  //可以用来判断一个对象是不是数组，弥补typeof方法无法判断确切类型的缺陷
//		alert(typeof arr);
//		(3)hasOwnProperty与constructor挂载的位置
//		function creatAnimal(){}
//		var a1=new creatAnimal();
//		creatAnimal.prototype.constructor
//		alert(a1.constructor);  
//		   ①所有的对象都属于Object
//		alert(a1.constructor==Object.prototype.constructor);  //false,说明constructor并没有挂载到Object
//		constructor这个方法,每一个函数被定义的时候会被自动添加到函数身上，是系统自动生成的，没有挂载到任何原型下面
		
//		   ②系统对象下的hasOwnProperty是挂载到对应对象的构造函数的原型下面的
//		var arr=[];
//		console.log(arr.hasOwnProperty==Array.prototype.hasOwnProperty);
//		   ③自定义对象的hasOwnProperty是挂载到Object.prototype下面的
//		function creatAnimal(){}
//		var a1=new creatAnimal();
////		creatAnimal.prototype.hasOwnProperty
//		console.log(a1.hasOwnProperty==Object.prototype.hasOwnProperty);
//		(4)新的挂载属性的方式，通过JSON格式批量挂载
//		function creatAnimal(){}
//		creatAnimal.prototype={
//			name:'小猫',
//			color:'black'
//		}
//		var a1=new creatAnimal();
////		alert(a1.name);
//		alert(a1.constructor);  //如果不处理constructor的话，构造函数变成了Object
//		function creatAnimal(){}
//		creatAnimal.prototype={
//			constructor:creatAnimal,//通过强制指定构造函数，绑定当前对象的构造函数
//			name:'小猫',
//			color:'black'
//		}
//		var a1=new creatAnimal();
////		alert(a1.name);
//		alert(a1.constructor);  //
		
//		三,instanceof  判断当前对象与构造函数在原型链上是否有关系
//		function creatAnimal(){}
//		var a1=new creatAnimal();
//		alert(a1 instanceof Array);
//		var arr=[];
//		alert(arr instanceof Array);  //也可以用来判断对象的类型
		
//		四,toString   
//		(1) 验证toString方法的挂载位置
//		var arr=[];
//		alert(arr.toString==Array.prototype.toString);  //系统对象的toString方法挂载到对应构造函数下面
//		alert(arr.toString==Object.prototype.toString);
//		function creatAnimal(){}
//		var a1=new creatAnimal();
//		alert(a1.toString==Object.prototype.toString);  //自定一对象的toString方法是挂载到Object.prototype下面的
		
//		(2)使用场景一，可以将对象转换为字符串
//		var arr=[1,2,3];
//		arr.toString();
//		alert(typeof arr.toString());  //string
//		alert(arr.toString());
//		Array.prototype.toString=function(){
//			return this.join('-');
//		}
//		alert(arr.toString());

//		(3)使用场景二,toString进行类型判断
//		function creatAnimal(){}
//		var a1=new Date();
//		alert(Object.prototype.toString.call(a1));
//		console.log(Object.prototype.toString.call(a1)=='[object Date]');

//		(4)使用场景三,进制转换
//		rgb(255,255,255)
//		#FF FF FF
//		var num=123;
//		alert(num.toString(16));  //把10进制转换成16进制
//		var num=10;
//		alert(num.toString(2))

//		五,总结一下,判断元素类型的方法
	</script>
</html>
